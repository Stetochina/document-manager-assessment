from copy import deepcopy

from rest_framework import status
from rest_framework.response import Response
from rest_framework.mixins import RetrieveModelMixin, ListModelMixin, CreateModelMixin
from rest_framework.viewsets import GenericViewSet
from rest_framework.decorators import action
from django.http import FileResponse


from ..models import FileRevision, FileInstance
from .serializers import FileRevisionSerializer
from ..utils import generate_file_hash, parse_url


class FileRevisionViewSet(CreateModelMixin, RetrieveModelMixin, ListModelMixin, GenericViewSet):
    """
    FileRevisionViewSet.
    The whole viewset was not necessary as we are neither updating not deleting files or revisions, so just specific Mixins
    were added to define the api and its dependant routes a bit more easily.
    """
    serializer_class = FileRevisionSerializer

    def get_queryset(self):
        """
        Defined the queryset by working only with user generated DocumentRevisions,
        as defined in the task.
        """
        return FileRevision.objects.filter(user=self.request.user)

    def create(self, request, *args, **kwargs):
        document_data = deepcopy(request.data)

        # get the url provided by the user and add a leading slash if omitted
        url = document_data['url'] if document_data['url'].startswith('/') else f"/{document_data['url']}"

        # get the information from the URL - the route provided as well as any query params
        url_data = parse_url(url)

        # filter out the queryset for FileRevisions not generated by current user to
        # check if the provided url is already taken by somebody else.
        queryset = FileRevision.objects.filter(url=url_data['path']).exclude(user=self.request.user)

        if len(queryset) > 0:
            raise Exception("Provided url is already in use")

        queryset = self.get_queryset()
        new_revision_number = 0

        # filter out all revisions for the given url provided and order from latest
        document_revision = queryset.filter(url=url_data['path']).order_by("-revision_number").all()

        # file provided by client (pop is used as the file data is not necessary for the creation of the FileRevision
        # instance but rather for the FileInstance.
        file = document_data.pop("file")

        # generate the file hash from the provided file
        file_hash = generate_file_hash(file[0])

        # Try to find an existing FileInstance with the same hash
        file_instance = FileInstance.objects.filter(file_hash=file_hash).first()

        # if no FileInstance found - create one.
        if not file_instance:
            file_instance = FileInstance(
                file_hash=file_hash,
                file_name=file[0].name,
                file=file[0]
            )
            file_instance.save()

        # if revision exists take the latest ones revision number and increment it.
        if document_revision:
            new_revision_number = document_revision[0].revision_number + 1

        # update the data for storing
        document_data.update({
            "user": request.user.id,
            "revision_number": new_revision_number,
            "file": file_instance.id,
            "url": url
        })

        serializer = self.get_serializer(data=document_data)
        serializer.is_valid(raise_exception=True)
        serializer.save(file=file_instance)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    @action(detail=False, methods=["GET"])
    def retrieve_revisions_by_hash(self, request, *args, **kwargs):
        """
        Retrieve all revisions for a user that match the given file hash
        """
        queryset = self.get_queryset()
        file_hash = request.query_params.get("file_hash")
        if not file_hash:
            raise Exception("You must provide 'file_hash' query param")

        # check if file exists for the provided hash
        file = FileInstance.objects.filter(file_hash=file_hash).first()

        if not file:
            raise Exception("No File exists with this hash")

        # if the file exists return all relevant file revisions for that file generated by the user
        return Response(self.get_serializer_class()(instance=queryset.filter(file=file.id), many=True).data)

    @action(detail=False, methods=["GET"])
    def get_document_by_url(self, request, *args, **kwargs):
        """
        Method that returns a file response for downloading based on
        the url provided as well as the revision query parameter.
        The revision query param is very important as it tells us
        which revision of the file we wish to download from the given url.
        """
        queryset = self.get_queryset()
        file_url = request.query_params.get("file_url")
        if not file_url:
            raise Exception("You must provide 'file_url' query param")
        url_data = parse_url(file_url)
        file_revision = None

        # if revision exists as a query param get the FileRevision with that specific revision_number
        if "revision" in url_data['params'].keys():
            qs = queryset.filter(url=url_data['path'], revision_number=url_data['params']["revision"][0])
            try:
                file_revision = qs.get()
            except FileRevision.DoesNotExist:
                pass
        # if there are no query params we return the latest revision for the file.
        elif not url_data['params']:
            file_revision = queryset.filter(url=url_data['path']).order_by("-revision_number").first()

        if not file_revision:
            raise Exception(f"Could not find a document with url '{file_url}'")

        # get the file path from the latest revision
        file_path = file_revision.file.file.path
        response = FileResponse(open(file_path, "rb"), as_attachment=True)

        response["Content-Disposition"] = f'attachment; filename="{file_revision.file.file_name}"'
        return response

    @action(detail=False, methods=["GET"])
    def download_file_by_hash(self, request, *args, **kwargs):
        """
        Method created for the purpose of directly downloading a document provided its hash.
        The file will be downloaded only in the case the user has at least 1 file revision tied to that file.
        """
        file_hash = request.query_params.get("file_hash")

        file = FileInstance.objects.filter(file_hash=file_hash).first()

        if not file:
            raise Exception("No File exists with this hash")

        queryset = self.get_queryset()

        # check if revisions by the user exist for the FileInstance
        revisions = queryset.filter(file=file.id).order_by("-revision_number")

        # if there are no revisions the user is not allowed to download the required file
        if not revisions:
            raise Exception("You do not have permission to download this file")

        # if at least 1 revision exists the user is allowed to download the requested file
        file_path = file.file.path
        response = FileResponse(open(file_path, "rb"), as_attachment=True)

        response["Content-Disposition"] = f'attachment; filename="{file.file_name}"'
        return response
